
    TRE tree processor manual
    Copyright (c) 2005-2007 Sven Klose <pixel@copei.de>

PURPOSE

    This is an interpreter for the TRE programming language, which provides
    a terse notation for programs and documents.

INVOKATION

    tre [optional source file]

USAGE

    tre [-h] [-i image-file] [source-file]

      -h  Print help message.
      -i  Load image file before source-file.
          See SYS-IMAGE-CREATE for details.

    First, the interpreter checks if an image of the standard environment
    exists. It is usually placed at ~/.tre.image. It is then loaded
    instead of the source files.
    Otherwise, the source files of the environment are read and an image
    file is written to speed up the next program start.

SYNTAX

    The interpreter reads single characters from the input stream and
    groups them into symbols and special characters. With special
    characters are grouped in to lists and trees.

    Lowercase letters are converted to uppercase. These are the special
    characters which may not be used with symbols; their uses will be
    explained in the following sections of this manual:

        Whitespaces
	    Including spaces and control characters, like the tabulator.
        '(' Opens an expression
        ')' Closes an expression
	'.' Dot
	''' Quote
	'`' Backquote
	',' Comma
	'#' Hash
	';' Comment (ignore everything until end of line)
	'"' Start/end of a character string constant

SYMBOLS

    Any single character or sequence of characters without whitespaces or
    special characters are grouped to 'symbols'. Every time a new symbol is
    read, it is added to the symbol table.

    A symbol may refer to any other object, including itself. Symbols
    refering to other objects are called 'variables'.

    Function names are separated from names of all other objects.

EXPRESSIONS

    One can create a list of symbols by embracing them with round brackets
    (see special characters).

	(1 2 3)
	A list with three symbols.

    Lists may also be nested, forming trees:

	(1 (2 3))
	A list containing symbol 1 and another list with symbols 2 and 3.

    If the interpreter read a top-level list, it evaluates the list; the
    list is interpreted as a function call, starting with a function object,
    continued by its arguments. This is why the two examples above cause
    an error if typed into the command prompt (the first elements are
    numbers, not functions. '+' is a built-in function that would do
    something useful:

	* (+ 2 3)
	5

    This is a list of object types of the TRE programming language:

	- variable; refers to other objects. It may be assigned a
	  function object and any other object that is not a function at the
	  same time,
	- number, contains a single floating-point value,
        - array, contains a fixed number of objects that can be indexed
	  using indices starting with 0,
	- strings, contains sequences of 0 or more characters,
	- built-in functions, essential functions required to build the
	  language with user-defined functions
	- built-in special forms; built-in function without argument
	- user-defined functions
	- user-defined special forms, also known as 'macros'
	- and list elements, referred to as 'conses'.

    Symbols are variables which point to themselves.

    Expressions are singly-linked lists. They are opened and closed with
    round brackets, '(' and ')' respectively. "(1 2 3)" would be a valid
    expression with three elements. It cannot be typed into the prompt
    because when expressions are evaluated, they're expected to be
    function calls.

EVALUATION

    As soon as a token or expression was read its elements are executed
    (also called 'evaluation' for the rest of this document) and replaced by
    their return values. The first element must be a function which is
    called with the remaining elements as its arguments.

        * (+ 1 2)
        3

        [Call to function '+' with arguments 1 and 2. 3 is the returned
         value.]

    As noted before, expression elements may also be expressions:

        * (+ 1 (+ 2 3))

    first evaluates to

	(+ 1 5)

    and then to

	6

QUOTING

    Evaluation requires the first argument to be a function. This is why
    lists cannot be entered literally to build data structures:

        * (1 2 3)
        function expected instead of number '1'.

    To circumvent evaluation use the QUOTE special form. Special forms
    are functions that take their arguments unevaluated. QUOTE returns
    a copy of its unevaluated arguments:

        * (quote (1 2 3))
        (1 2 3)

    Because quoting is used very often, there's an abbreviated form:

        * '(1 2 3)
        (1 2 3)

    If you use the BACKQUOTE (or "`" for short, QUASIQUOTE (",") and
    QUASIQUOTE-SPLICE (",@") functions insert their single evaluated
    argument into the BACKQUOTEd expression.

    QUASIQUOTE inserts an expression like a single atom.

        * (setq a 3)
        3
        * `(1 ,a 2)
        (1 3 2)

    QUASIQUOTE-SPLICE splices a list into another

        * (setq l '(7 8 9))
        (7 8 9)
        * `(1 ,@l 3)
        (1 7 8 9 3)

    COLLECTING-QUOTE collects a set of objects which is to be inserted by the
    parent QUASIQUOTE or QUASIQUOTE-SPLICE. Its abbreviated form is the accent
    circonflex ('^').
    Each time a COLLECTING-QUOTE is evaluated, its result is appended to the set.

FUNCTIONS

    All functions require a list of argument definitions.
    Each element of the list is a symbol representing a value passed to the
    function or a keyword specifying optional or keyword-associated arguments.
    Argument definitions may be nested.

    (defun myfun (name (surname middle-name)) ... )
    (myfun "Klose" ("Sven" "Michael"))

    The interpreter accepts the &REST, &OPTIONAL and &KEY keywords in
    argument list definitions.

    The &REST keyword will return a list of remaining arguments.

    The &OPTIONAL keyword will initialise following missing arguments to
    NIL.

    * (#'((&optional var) var))
    NIL

    An alternative intialisation value may be declared inside a list:

    * (#'((&optional (var 23) var))
    23

    The &KEY keyword will search for the following keywords in the
    arguments passed to the function and will take the following value.
    Usually the keyword namespace is specified by prepending a colon ':'
    to the keyword when calling the function. If a key was not specified,
    it is initialised to NIL.

    * (#'((&key comment) (print comment)) :comment "FNORD!")
    "FNORD"

SPECIAL FUNCTIONS

    A special functions is like an ordinary function but is evaluated
    in the environment of its caller.

DATA STRUCTURES

    Square brackets express access to a list or tree structure. The first
    element in a 'square' expression is the data structure from which an
    element should be read, followed by the element name. Further elements
    may follow, if the former element is also a data structure.
    If the element name is an integer, it denotes the Nth element in the list.

ABBREVIATED TREE NOTATION

    To reduce the number of round brackets, curly brackets can be used instead.
    Like with round brackets, expressions opened with curly brackets must
    be ended with the same number of closing curly brackets. But all missing
    round brackets that come after a curly bracket are closed implicitly:

    {format t "Hello world number ~A!" (+ 1 1}

    The missing closing, round bracket is validated. This effect is nestable:

    {html
      `(head (title "My document"))
       (body
         (h1 "Phone numbers from the database")
         {table
           ,@(foreach result (mysql-query "SELECT * FROM people"
                                          :database "people-db"
                                          :host "localhost"
                                          :user "sven" :password "fnord")
               ^(tr
                  (td [result "name"])
                  (td [result "phone"])}
         (a :href "/" "Link back home")}

### DEBUGGER ################################################################

    In case an error occured or (INVOKE-DEBUGGER) is evaluated, the
    debugger is invoked, prompting you for input. It understands a set of
    single-character commands. The debugger prompt has the following format.

        [<return value>:]<debug level> ]

    The prompt may contain a return value:

        (1 2 3) : 1]
        1]

    Commands may take arguments; prefixed spaces are ignored: You may
    type 'pSYMBOL' instead of 'p SYMBOL'.

    Here is a list of all commands:

    Stack
	u	Move up to calling function.
        d       Move back down a function.
	t	Print function-call backtrace.

    Printing:

	p S	Print contents of symbol S. If the print contains the
                currently evaluated expression, the expression is embraced
                with arrows of the form "===>expression<===".

    Execution:

	s	Step into function.
	n	Execute expression including arguments.
	x E	Execute TRE expression.
        *	Set return value, which is used to replace the
                erroraneous expression when continuing.
                You cannot set the return value if an error is
                unrecoverable, which is printed when the debugger is
                invoked.
        c	Continue execution with current return value.

    Breakpoints and watch expressions:

	b N	Set breakpoint for calls to function N. Prints names of
                breakpointed functions if no arguments are given.
	k N	Remove breakpoint for function N.

    Miscellaneous:

	h	Prints a help page
	q	Terminate program, return to toplevel.

### NON-STANDARD BEHAVIOURS #################################################

VARIABLES AND SYMBOLS

    Variables and symbols are basically the same. Symbols evaluate to
    themselves.

COMPUTATIONAL VALUES

    Number atoms are not looked up for computational values in favor of
    performance.

    * (eq 1 (+ 0 1))
    NIL

    (+ 0 1) will evaluate to a new number.

    Recursive functions will waste a lot of numbers.

### FUNCTION REFERENCE #####################################################

TERMINOLOGY

    LISTS

    If something must be a list, it must be a cons or NIL (see also LISTP).

    A documentation has the following form:

    (name argument-definition) - type of function
	Descriptive text.

   'type of function' may be one or both of

	- non-standard
	- built-in

    followed by

	- function
	- special form
	- macro.

    Optionally, '(r)' tells that the function cannot be implemented in
    TRE to run the interpreter.

NUMBERS

    Only floating point numbers are supported.

    (+ &rest args) - built-in function (r)
	Returns the sum of args.

    (- na &rest nd) - built-in function (r)
	When called with one argument, returns -nl. When called with
	additional arguments, they're substracted from nl.

    (* &rest args) - built-in function (r)
	When called without arguments, 1 is returned. Otherwise returns
	the product of the arguments.

    (/ na &rest args) - built-in function (r)
	When called with one argument, 0 is returned. Otherwise returns
	the first argument divided by the rest.

    (INTEGER number) - built-in function
	Same as CHAR for integers.

    (MOD x y) - built-in function (r)
	Returns remainder of x / y.

LOGICAL OPERATORS

    (LOGXOR &rest args) - built-in function
	Exclusive OR numbers.

COMPARISON

    (= x y) - built-in function (r)
	Returns T if the values of x and y match.

    (< x y) - built-in function (r)
	Returns T if number x is less than number y.

    (> x y) - built-in function
	Returns T if number x is greater than number y.

    (>= x y) - function
	Return T if x is greater than or equal to y.

    (<= x y) - function
	Return T if x is less than or equal to y.

    (EQ o1 o2) - built-in function (r)
	Return T if the two objects are identical.

    (EQL o1 o2) - built-in function
	Return T if the two objects are identical, or if they are numbers
        or characters that have the same value. EQL is the default testing
	predicate.

    (EQUAL x y) - function
	Like EQ but traverses conses. Compares only atoms.

    (EVENP x) - function
	Returns T if x is an even number.

    (NEQL o1 o2) - non-standard function
	Like (not (eql o1 o2)).

    (NOT x) - function
	Returns T if x is not NIL.

    (NULL x) - function
	Same as LISTP. Returns T if x is a cons.

    (RANGE-P num bottom top) - non-standard function
	Returns T if the number is within the range starting at bottom
	and ending at top (>= bottom and <= top).

TYPES

    (ATOM obj) - built-in function (r)
        Returns T if obj is not a cons.

    (CHARACTERP obj) - built-in function
	Returns T if the argument is a character.

    (FUNCTIONP obj) - built-in function
	Returns T if the argument is a function.

    (NUMBERP obj) - built-in function
	Returns T if the argument is a number.

    (STRINGP obj) - built-in function
	Returns T if the argument is a string.

    (ZEROP x) - function
	Returns T if x contains the number 0.

CHARACTERS

    (CODE-CHAR number) - built-in function
        Returns new character object with converted value of 'number'.

SYMBOLS

    (INTERN symbol-name &OPTIONAL package-name) - built-in function
        Returns already existing or new symbol in package.

    (MAKE-SYMBOL string) - built-in function
        Returns newly created self-referencing atom. Already existing
	atoms are reused.

    (SYMBOL-FUNCTION var) - Built-in function/place
	Get function assigned to variable.

    (SYMBOL-NAME obj) - built-in function
	Returns the symbol name of 'obj' as a string.

    (SYMBOL-VALUE var) - Built-in function
	Get value assigned to variable.

VARIABLES

    (DEFVAR variable &OPTIONAL init-value) - macro
	Defines and initialises a variable. This is equivalent to
	SETF.

    (LABELS ((function_name argument_list body)*) exprs) - macro
	Create local functions visible while evaluating
	'exprs'. Local functions may call themselves or formerly
	defined functions.

    (LET ((symbol value)*) body) - macro
	Call body in a new environment where symbol is locally assigned
	a new value. This macro generates a single LAMBDA.

    (LET* ((symbol value)*) body) - macro
	Call body in a new environment where symbol is locally assigned
	a new value. Value expressions may contain symbols formally
	initialised. This macro generates nested LAMBDAs.

    (MULTIPLE-VALUE-BIND variables expression body*) - macro
        Binds variables to VALUES returned by expression and
        evaluates the body. If the list of variables is longer than the
	list values returned by the expression, the remaining variables
	are set to NIL. Remaining values are ignored.

    (SET symbol value) - macro
	Give symbol an evaluated value.

    (SETQ {symbol value}*) - built-in special form (r)
	Gives each symbol a new value. The former value is lost.
	Returns the last value set.

    (SETF {place value}*) - macro
	Gives 'place' a new unevaluated value. If place is a getter
	function call it is expanded to the correspondig setter,
	e.g. a call to CAR is transformed to a call to RPLACA.
        Returns 'value'. See also DEFUN.

    (VALUES expression*) - function
        Returns multiple values for MULTIPLE-VALUE-BIND.

    (XCHG a b) - macro
	Swaps values of the arguments.

MATH

    (1+ x) - function
	Return x incremented by 1.

    (1- x) - function
	Return x decremented by 1.

    (ABS x) - function
	Return positive value of x.

    (DECF place &OPTIONAL (n 1)) - macro
	Decrement place by n.

    (INCF place &OPTIONAL (n 1)) - macro
	Increment place by n.

CONS

    (CONS car cdr) - built-in function (r)
	Returns a cons containing the first argument as the CAR
	and the second argument as the CDR.

    (CONSP obj) - built-in function (r)
	Returns T if the argument is a cons.

    (CAR cons) - built-in function (r)
	Returns the CAR of a cons. Returns NIL if the cons is NIL.

    (CDR cons) - built-in function (r)
	Returns the CDR of a cons. Returns NIL if the cons is NIL.

    (FIRST | SECOND | THIRD | FOURTH | FIFTH | SIXTH | SEVENTH | EIGHTH |
     NINTH | TENTH list) - function
	These functions return the first, up to the tenth, element of a list.

    (RPLACA cons value) - built-in function (r)
	Set adress register of 'cons' to new value. Return 'cons'.

    (RPLACD cons value) - built-in function (r)
	Set decrement register of 'cons' to new value. Returns 'cons'.

    (RPLAC-CONS cons cons-new) - non-standard function
	Replaces the values of cons by the values of cons-new.

LISTS

    (APPEND &REST lists) - function
	Returns 'lists' concatenated. All lists, except the last, are
	copied.

    (BUTLAST list) - built-in function
	Returns last without last element.

    (CAAR list) - function
	Like (CAR (CAR list)).

    (CADAR list) - function
	Like (CDR (CAR list)).

    (CADR list) - function
	Like (CAR (CDR (CAR list))).

    (CDAR list) - function
	Like (CDR (CAR list)).

    (CDDR list) - function
	Like (CDR (CDR list)).

    (COPY-LIST tree) - function
	Returns toplevel copy of list of tree.

    (COPY-TREE tree) - function
	Returns copy of a list including all sublevels.

    (LAST list) - function
	Returns last cons of a list.

    (LIST element*) - built-in function
	Returns a new list containing the arguments.

    (LISTP x) - function
	Returns T if x is a cons or NIL.

    (NTH index lst) - function
	Return element at position 'index' from 'lst', starting with 0.
	NIL is returned if 'index' exceeds the number of elements.

    (NTHCDR index list) - function
        Returns the nth CDR of a list. An index of 0 returns the first
        cons.

LIST MANIPULATION

    (ADJOIN object list) - function
	If object is a member of list, returns list. Otherwise, the list
	is returned with the object prepended.

    (REMOVE-IF test-function list) - function
	Remove elements from list.

    (REVERSE list) - function
	Returns reversed copy of a pure.

    (NCONC list*) - function
        Concatenates lists into single list by replacing the cdr of each
        last cons and returns it. (This function is destructive.)

LIST SEARCH

    (MEMBER element list*) - function
	Returns T if element is a member of any of the pure lists.

LIST TRAVERSAL

    (DEFINE-MAPPED-FUN mapfun name arg-list &REST body) - non-standard
	function
	Creates a function which takes a list and calls mapfun for
	traversal. arg-list and body are used to create a function
	which serves as the first argument to mapfun. The argument to
	the created function will be the second argument to mapfun.

    (DEFINE-MAPCAR-FUN name arg-list &REST body) - non-standard function
	Like DEFINE-MAPPED-FUN but with mapfun set to MAPCAR.

    (MAP function list*) - function
	Call function with each cons of the lists as arguments.
	On the first call the first conses in the lists are used, on the
	second call the second conses are applied, and so on, until a
	list runs out of elements.

    (MAPCAR function list*) - function
	Call function with each element of the lists as arguments.
	On the first call the first elements in the lists are used, on the
	second call the second elements are applied, and so on, until a
	list runs out of elements.

    (MAPCAN function list*) - function
	Like MAPCAR but concatenates the returned lists.

FUNCTIONS

    (APPLY func &REST args) - built-in function (r)
	Apply arguments args to function func. The last element of args
        must be a list which is appended to the former args. The last
	argument is ignored if NIL.

    (DEFUN name args documentation-string body) - macro
	Defines a global function. The body is placed in a BLOCK named
	NIL and a TAGBODY.
	The documentation string is ignored.
	If name is a list of the form (SETF name), the function is called
        if 'name' is used as a SETF place. It must then take the value
	as the first argument, and the place as the second argument.

    (DOCUMENTATION funcname) - function
	Returns documentation string of function.

    (FUNCTION (LAMBDA argument-list body)) - built-in special form (r)
    (FUNCTION argument-list body)
    (FUNCTION symbol)
	Create new function or return function bound to variable.

    (MACRO argument-list body) - built-in special form
	Same as LAMBDA but returns a macro.

    (SPECIAL argument-list body) - built-in special form
	Returns a function whose arguments are not evaluated when called.

MACROS

    (DEFINE-COMPILER-MACRO (name args body) - macro
	Defines a macro which is used by the compiler to translate
	built-in functions to native TRE expressions.

    (DEFMACRO name args documentation-string body) - macro
	Like DEFUN but the arguments are not evaluated before the macro
   	is called and the body's result value is evaluated after return from
	the body.

    (GENSYM) - function
	Returns new generic symbol.

    (MACRO argument-list body) - built-in special form
	Returns unnamed macro-expansion for use before evaluation.
        Calls to macro-expansions are replaced by their return value
	when executed the first time.

    (MACROEXPAND-1 form) - built-in function
	Expand macro calls in form. Does not expand nested macros.
	The TRE function assigned to *MACROEXPAND-HOOK* is used for
	expansion. If *MACROEXPAND-HOOK* is NIL, nothing is done.

    (MACROEXPAND form) - built-in function
	Expand all macro calls in form.

    (MACROLET ((function_name argument_list body)*) exprs) - not implemented
	Like LET* for LABELS.

    (WITH-GENSYM { symbol | symbol-list } &REST body) - macro
	Creates one or more gensyms for evaluation of body.

EVALUATION

    (BACKQUOTE expression) - special form
	Evalates QUASIQUOTE and QUASIQOTE-SPLICE in expression and
	returns it. The short form is "`expression".

    (EVAL expression) - built-in function
	Evaluates expression and returns its result.

    (FUNCALL function &REST args) - function
        Calls function with arguments.

    (IDENTITY object) - built-in function
	Returns object.

    (LOAD path) - built-in function
	Loads file at 'path' and evaluates it.

    (QUASIQUOTE expression) - keyword
	Evaluate expression within a BACKQUOTE and insert it into the point
	of return. The short form is ",expression".

    (QUASIQUOTE-SPLICE expression) - keyword
	Evaluate expression within a BACKQUOTE. The return value of the
	expression must be a list which is spliced into the point of return.
        The short form is ",@expression".

    (QUOTE expression) - built-in special form
	Returns expression unevaluated. The short form is "'expression".

COMPILATION

    (COMPILE functionname) - function
        Compiles a function and returns it. See the compiler section
	of this manual for more details.

    (COMPILE-ALL) - function
	Compile just everything.

CONTROL FLOW

    (AIF test-expression true-body [false-body]) - non-standard macro
	Like IF but assigning the value of 'test' to variable '!'.

    (AND expression*) - built-in special form
	Evaluate expressions until a NIL value is returned.

    (ANIF name test-expression true-body [false-body]) - non-standard macro
	Like IF but assigning the value of 'test' to variable 'name'.

    (ANWHEN name test expressions*) - non-standard macro
	Like WHEN but assigning the value of 'test' to variable 'name'.

    (AWHEN test expressions*) - non-standard macro
	Like WHEN but assigning the value of 'test' to variable '!'.

    (BLOCK symbol expression*) - built-in special form
	Evaluates expression by expression and returns the last.
	On evaluation of RETURN-FROM inside the body, evaluation of the
        block is terminated.

    (CASE value (match expression)*) - macro
        Evaluates first expression whose 'match' is EQUAL to 'value'.

    (COND (test expression)*) - built-in special form (r)
	Evaluates test-expression pairs in order. If a test returns non-NIL,
        the expression is evaluated and returned. If no test matches NIL is
	returned.

    (GO tag) - built-in special form
	Inside a TAGBODY, continue evaluation at tag.

    (IF test-expression true-body [false-body]) - built-in special form
	If test-expression returns T, true-body is evaluated, false-body
	is evaluated otherwise. The result of the evaluated body is returned.
	If false-body is not given, NIL is returned.

    (OR expression*) - built-in special form
	Evaluate expressions until a non-NIL value is returned.

    (PROG1 expression*) - macro
	Evaluates expressions and returns the value of the first.

    (PROGN expression*) - built-in special form
	Evaluates expressions and returns the value of the last.

    (QUIT) - built-in function
	Terminates the application.

    (RETURN-FROM tag expression) - built-in special form
	Exit BLOCK named tag and return the evaluated expression.

    (TAGBODY {tag | expression} *) - built-in special form
	Evaluates expression by expression and returns NIL. Tags are
	ignored.
	On evaluation of GO inside the body, evaluation is continued
	after the tag specified.

    (UNLESS test expression*) - macro
	Same as (WHEN (NOT test) expression*).

    (WHEN test expressions*) - macro
	Evaluate expressions in order, returning the value of the last
        if test is not NIL

    (WHILE test result &REST body*) - macro
	Loops over body unless test evaluates to NIL and returns result.

ERRORS

    (ERROR string) - built-in function
	Print string and enter debugging mode.

ITERATION

    (DOLIST (var list [result]) expressions*) - macro
	Create new local variable var and evaluate expressions for each
	element in list.
        The DOLIST expansion is encapsulated in a block named NIL
	(see RETURN). The result is returned if it is specified, otherwise
	NIL is returned.

    (DOLIST-INDEXED (var index list result &key (start-index 0)
		    expressions*) - non-standard macro
	Create new local variable var and evaluate expressions for each
	element in list. 'index' is initialized to start-index and
        incremented after each iteration. The expansion is encapsulated in
        a block named NIL (see RETURN). The result is returned if it is
	specified, otherwise NIL is returned.

LOOPS

    (DOTIMES (var integer [result]) body*) - macro
        Counts local variable var from 0 up to the integer value - 1
	and evaluate body expressions each time.
        The DOTIMES expansion is encapsulated in a block named NIL
	(see RETURN). DOTIMES returns the result if it is specified,
        otherwise NIL is returned.

    (DO (var init [update])* (test [result]*) body*) - macro
	Initialise each var to init and evaluate body as long as test
        evaluates to NIL. After evaluation of the body, all variables
	are updated. 'result' is evaluated on return if specified.

    (LOOP &REST body) - macro
	Infinitely loop over body. The CL loop language is not
	implemented.

ASSOC LISTS

    (ASSOC key list) - function/place
	Looks up entry in associative list.

    (ASSOC-CONS key list) - function
	Like ASSOC but returning the cons containing the key and the value.

    (ACONS key val lst) - function
	Prepends key/value pair to associative list.

    (ACONS! key val place) - non-standard macro
	Like ACONS but sets place.

    (PAIRLIS key-list value-list) - function
	Merges key and value list into an associative list. An error is
	issued if the lists don't have the same length.

    (CARLIST alist) - function
	Returns keys of an associative list.

    (CDRLIST alist) - function
	Returns values of an associative list.

    (COPY-ALIST alist) - function
	Return a copy of an associative list. Keys and values are
	the same.

STACKS

    (PUSH value stack) - macro
	Prepend element to list and return it.

    (POP stack) - macro
        Return first element from list and make 'stack' point to the
	next element.

    (POP! stack) - non-standard function
	Like POP but replacing the registers of the first elements by
	the registers of the second element.

CHARACTERS

    (ALPHA-CHAR-P char) - function
	Returns T if 'char' is an alphabetic character.

    (ALPHANUMERICP char) - function
	Returns T if 'char' is an alphabetic character or a digit.

    (CHAR-UPCASE char) - function
	Returns the upper case equivalent of 'char' or 'char' itself.

    (DIGIT-CHAR-P char) - function
	Returns T if 'char' is a digit.

    (LOWER-CASE-P char) - function
	Returns T if 'char' is a lower case, alphabetic character.

    (UPPER-CASE-P char) - function
	Returns T if 'char' is an upper case, alphabetic character.

STRINGS

    Strings are not unique. (EQ "a" "a") evaluates to NIL. Use STRING=
    instead. Strings are also sequences.

    (CHAR-STRING character) - non-standard function
	Converts single character to new string.

    (LIST-STRING string) - non-standard function
	Makes string from list of numbers. If string is NIL, NIL is returned.
    
    (MAKE-STRING n) - built-in function
	Makes new string consisting of n elements.

    (STRING-CONCAT string*) - built-in function
	Concatenates arguments to new string.

    (STRING-UPCASE string) - function
	Return new string with upper case characters.

    (STRING obj) - built-in function
	Returns obj converted to a string. Numbers and symbol conversion is
        supported. It is an error trying to convert other types.

    (STRING= str1 str2) - function
	Returns T if strings match.

ARRAYS

    (MAKE-ARRAY size*) - built-in function
	Returns newly created array of one ore more dimensions.
	The number and size of dimensions is limited by construction.
	Indices may not be negative.

    (AREF array index*) - built-in function/place
	Return element of array. The number of indices must match the
	number of dimensions of the array.

HASH TABLES

    (GETHASH key hash-table &OPTIONAL default) - function/place
	Lookup element with 'key' from 'hash-table'. 'optional' is
	unused.

    (MAKE-HASH-TABLE &KEY test size rehash-size rehash-threshold) -
	function
	Makes a new hash table. 'test' is a predicate function, which
	is #'EQ by default. 'size' is the table size (not limiting the
	total number of elements). 'rehash-size' and 'rehash-threshold'
        are unused.

	Currently, only numbers and strings can be used as keys.

QUEUES *NON-STANDARD*

    (DOLIST-QUEUE (var queue [result]) expressions*) - macro
	Like DOLIST for queues.

    (ENQUEUE queue value) - macro
	Place value on top of queue.

    (MAKE-QUEUE) - macro
	Makes the head element of a queue.

    (QUEUE-LIST) - macro
	Return the list of queue elements.

    (WITH-QUEUE { name | name-list} &REST body) - macro
	Creates one or more queues before body is evaluated.

SEQUENCES

    Lists and strings are sequences.

    (SOME predicate &REST sequences) - function
	Returns T if 'predicate' returns T for any element of 'sequences'.

    (ELT sequence index) - built-in function/place
	Returns zero-indexed element from sequence.

    (EVERY predicate &REST sequences) - function
	Returns T if 'predicate' returns T for all elements of 'sequences'.

    (FIND value sequence &KEY start end from-end test test-not)
	Finds element in list. 'start' and 'end' define the starting and
	ending index searched. 'start' and 'end' may be swapped to make
	sense. If 'from-end' is not NIL, the search is performed backwards.
	The default testing predicate may be overridden by 'test' or
	'test-not'. The boolean returned by the 'test-not' function will
	be negated.

    (FIND-IF predicate sequence &KEY start end from-end) - function
	Finds element in list for which 'predicate' returns T. 'start'
	and 'end' define the starting and ending index searched. 'start'
	and 'end' may be exchanged to make sense. If 'from-end' is not NIL,
	the search is performed backwards.

    (LENGTH sequence) - built-in function
	Returns number of elements in sequence.

    (POSITION value sequence &KEY start end from-end test test-not) - function
	Like FIND, but returning the position of the element found
	(zero-indexed) or NIL.

    (SUBSEQ sequence start &OPTIONAL end) - function
	Return copy of subsequence of the same type. The ending position is
        not included.

STRUCTURES

    (DEFSTRUCT name &REST fields) - macro
	Defines a structure of name 'name' with 'fields'. A constructor named
	'MAKE-name' is defined. For each field a getter function is defined
        of name 'name-field' which may be used as a place with SETF.

	A field in 'fields' may be a symbol or a list containing the
	symbol and its init form:

	    (defstruct mystruct
	      fnord		      ; Will be initialised to NIL.
	      (text "Hello World!"))  ; Field will contain the string.

	In one of 'fields' the :constructor option may be used, specifying
	the name of the constructor which would otherwise be MAKE-name.

    (WITH-STRUCT struct-name var &REST body) - non-standard macro
	Binds all fields of structure 'var' of type 'structure-name' to
	equally named variables for the evaluation of 'body'.

STREAMS

    If the optional stream argument is not give, the standard input or
    output stream is used.

    (END-OF-FILE &OPTIONAL stream) - function
        Returns T is stream is at the end of a file. NIL otherwise.

    (FORCE-OUTPUT &OPTIONAL stream) - function
	Force buffered output out.

    (FRESH-LINE &OPTIONAL stream) - function
	Open a new line not already done.

    (FRESH-LINE? &OPTIONAL stream) - non-standard function
	Checks if output stream is at the beginning of a line.

    (GET-OUTPUT-STREAM-STRING string-stream) - function
	Returns string accumulated string-stream.
	See also MAKE-STRING-OUTPUT-STREAM.

    (MAKE-STRING-OUTPUT-STREAM) - function
	Returns a stream which accumulates all strings written to
        it. See also GET-OUTPUT-STREAM-STRING.

    (PRINC obj &OPTIONAL stream) - function
        Print obj in human-readable format.

    (PEEK-CHAR &OPTIONAL stream) - function
	Peek next character from input stream. The character will remain
        in the stream.

    (READ-CHAR &OPTIONAL stream) - function
	Take character from input stream.

    (READ-LINE &OPTIONAL stream) - function
	Read line from stream.

    (TERPRI &OPTIONAL stream) - function
	Open a new line.

    (WITH-DEFAULT-STREAM str &REST body) - non-standard macro
	Set 'str' to *standard-output* if 'str' is T or create a
	string-stream if 'str' is NIL, evaluate 'body' and return the
        stream-string if 'str' is NIL.
 
PRINTING

    (PRINT obj)	- built-in function
	Print object in TRE notation. Returns the printed object.

DEBUGGING

    (INVOKE-DEBUGGER) - built-in function
	Launches the debugger.

    (SET-BREAKPOINT variable) - built-in special operator
	Set breakpoint for function in variable.

    (REMOVE-BREAKPOINT variable) - built-in special operator
	Remove breakpoint for function in variable.

    (END-DEBUG) - non-standard built-in function
        Return to global environment.

ARGUMENTS

    (ARGUMENT-EXPAND argument-definition values) - function
	Expands argument and returns two flat lists (see VALUES). The
	first contains the argument keywords, the second contains the
	values.

EXECUTABLES AND IMAGES

    (SYS-IMAGE-CREATE filepath &OPTIONAL init-fun) - built-in function
        Creates or replaces machine snapshot at 'filepath'.
        The snapshot can is executable if the interpreter is in the
        search path.
        'init-fun' is an optional function that is evaluated after
        the image is loaded.

    (SYS-IMAGE-LOAD filepath) - built-in function
        Replaces the running environment by an image.  If an initialisation
        function was specified at the time the image was dumped, it is
        evaluated.

ALIEN INTERFACE

    The alien interface allows to link shared libraries and to call C
    functions.

    (ALIEN-DLOPEN path) - built-in function
	Expects a path to an object file. Returns a numeric handle.
	The object file is dynamically linked to the environment.

    (ALIEN-DLCLOSE handle) - built-in function
	Unlinks an object file from the environment. An error is caused
	if something goes wrong.

    (ALIEN-DLSYM handle symbol_string) - built-in function
	Returns the numeric address of a symbol in the linked object
	file specified by 'handle'.

    (ALIEN-DLCALLx handle [args]) - built-in function
	Calls a C function in linked object file specified by handle.
	x is the number of arguments to pass to the function. 0 means
	no arguments. Up to four arguments are supported.

MISCELLANEOUS

    (GC) - built-in function
	Triggers garbage collection. Prints statistics if compile-time
	option TRE_VERBOSE_GC is set. Returns NIL.

INTERNAL FUNCTIONS

    Internal functions should never be used outside the initial environment,
    since misuse will cause damage to the environment.

    %SET-ELT
    %SET-AREF
	Setters for built-in functions.

    (%MACROCALL macro arguments) - Built-in function
	Call macro. 'arguments' is supposed to be a list.

    (%SET-ATOM-FUN var fun) - Built-in special form
	Assign new function to a variable's function slot.

    (%MKFUNCTIONATOM function_definition) - Built-in function
	Returns a function. function_definition must be a cons. CAR
        must contain the argument definition and CDR must contain the
	function body.

    (%FOPEN file mode) - Built-in function
	Opens a file using fopen() (see Standard-C library documentation
 	for details). Returns a numeric handle.

    (%PRINC handle char) - Built-in function
	Print character in internal file stream opened with %FOPEN.
	'char' is required to be a number.

    (%FORCE-OUTPUT) - Built-in function
	Flush output buffers on all streams.

    (%READ-CHAR handle) - Built-in function
	Read character from internal file stream. Returns a number.

    (%FEOF handle) - Built-in function
	Test end-of-file on internal stream.

    (%ATOM-LIST) - Built-in function
	Returns list of all atoms defined.

### VIRTUAL FUNCTIONS #######################################################

    This functions are low-level primitives to break up code into simpler
    units by expandings compiler macros. They're just symbols used by
    compiler, not real functions.

    (%FUNREF fun obj)
	Combines a function reference with the first argument that must
        be passed to that function.

    (%SET atom expr)
        Same as SETQ, but taking only two arguments.

    (%VEC vec index)
        Place of an array element.

    (%VM-SCOPE &BODY body)
	Like a TAGBODY, but returns the last expression evaluated.

    ~%RET
        This is a placeholder for return values of VM-SCOPEs.

### GLOBAL CORE VARIABLES ###################################################

    *ENVIRONMENT-PATH*
	Root directory of the environment.

    *MACROEXPAND-HOOK*
	Points to function which takes an expression and does a single
        macro-expansion like MACROEXPAND-1.

    *VERBOSE-EVAL*
	When set to T, everything passed to the EVAL function is PRINTed
	before.

    %LAUNCH-FILE
	A TRE file specified on the command-line, evaluated after the
	environment.

### GLOBAL ENVIRONMENT VARIABLES ############################################

    *CURRENT-MACRO*
	Set to macro function before it is called (during macro-expansion)
        and reset to NIL after its return.

    *FORBID-EMPTY-DEFUN*

    *STRUCT-DEFS*
	An associative array of all structure definitions make with DEFSTRUCT.

    *UNIVERSE*
	List of all symbols that should not be removed.

    *VERBOSE-EVAL*
	When set to T, everything passed to the EVAL function is PRINTed
	before.

### COMPILE-TIME OPTIONS ####################################################

    Compile-time options are useful for debugging, or if the size of the
    application is to be reduced.

    TRE_BOOTFILE
        Path to environment toplevel file, relative to TRE_ENVIRONMENT.

    TRE_BOOT_IMAGE
        Path to cached environment dump which is loaded instead of
        TRE_BOOT_IMAGE (if exists).

    TRE_BOOT_IMAGE_HEADER
        String to prefix images with. Used to for hash bang and informative
        messages.

    TRE_DIAGNOSTICS
       Do diagnostic checks.

    TRE_GC_DEBUG          
	Run garbage collector everywhere.

    TRE_ENVIRONMENT
        Path to environment directory.

    TRE_NO_MANUAL_FREE    
	Don't free internal garbage manually, leave it for mark-and-sweep
	removal.

    TRE_PRINT_MACROEXPANSIONS
	Print macroexpansions in read-eval loop.

    TRE_READ_ECHO         
	Echo what is READ in the read-eval loop.

    TRE_VERBOSE_GC        
	Print statistics after GC.

    TRE_VERBOSE_LOAD      
	Print what files are loaded.

    TRE_VERBOSE_EVAL      
	Print what is evaluated if global variable *VERBOSE-EVAL* is T.

    TRE_VERBOSE_READ      
	Print READ expressions in read-eval loop.

### TERMINOLOGY ############################################################

    expression, S-expression ("symbolic expression")
	A textual representation of an object.

    non-atomic S-expression ("dotted-pair")
	A binary tree of conses whose leaf nodes are atoms.

    pure list
	An S-expression where every element x

	    (AND (NOT (CONSP (CAR x)))
	         (LISTP (CDR x)))
	    => T
