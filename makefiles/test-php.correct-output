Test 1, APPLY one argument</br>Test 2, APPLY many arguments</br>Test 3, APPLY many arguments</br>Test 4, EQ with symbols</br>Test 5, EQ with three symbols</br>Test 6, EQL with symbols</br>Test 7, EQL with three symbols</br>Test 8, EQL with numbers</br>Test 9, BACKQUOTE</br>Test 10, QUASIQUOTE</br>Test 11, QUASIQUOTE-SPLICE</br>Test 12, LIST? for cell</br>Test 13, LIST? for NIL</br>Test 14, LIST? fails with number</br>Test 15, LIST? fails with symbol</br>Test 16, COUNT</br>Test 17, %SIMPLE-MAPCAR</br>Test 18, ++</br>Test 19, --</br>Test 20, NOT works with NIL</br>Test 21, NOT works with T</br>Test 22, KEYWORDP recognizes keyword-packaged symbols</br>Test 23, KEYWORDP works with standard symbols</br>Test 24, CAR accepts NIL</br>Test 25, CDR accepts NIL</br>Test 26, RPLACA returns cons</br>Test 27, RPLACD returns cons</br>Test 28, ATOM recognizes atoms</br>Test 29, ATOM fails on conses</br>Test 30, CONS?</br>Test 31, CONS? fails on atoms</br>Test 32, CONS? fails on numbers</br>Test 33, CONS? fails on characters</br>Test 34, CONS? fails on strings</br>Test 35, CONS? fails on arrays</br>Test 36, SYMBOL?</br>Test 37, SYMBOL? fails on cells</br>Test 38, SYMBOL? fails on numbers</br>Test 39, SYMBOL? fails on characters</br>Test 40, SYMBOL? fails on strings</br>Test 41, SYMBOL? fails on arrays</br>Test 42, NUMBER? recognizes numbers</br>Test 43, NUMBER? recognizes characters</br>Test 44, NUMBER? fails on arrays</br>Test 45, NUMBER? fails on symbols</br>Test 46, CHARACTER? recognizes characters</br>Test 47, CHARACTER? fails on symbols</br>Test 48, CHARACTER? fails on cells</br>Test 49, CHARACTER? fails on numbers</br>Test 50, CHARACTER? fails on arrays</br>Test 51, CHARACTER? fails on strings</br>Test 52, EQL wants same type of numbers</br>Test 53, FUNCTION? recognizes functions</br>Test 54, FUNCTION? recognizes built-in functions</br>Test 55, STRING? recognizes strings</br>Test 56, STRING? fails on numbers</br>Test 57, STRING? fails on symbols</br>Test 58, CODE-CHAR converts number to char</br>Test 59, CHAR-CODE converts char to number</br>Test 60, SETQ returns the last value set</br>Test 61, IDENTITY</br>Test 62, LAST works</br>Test 63, LAST return NIL for empty list</br>Test 64, == works with floats</br>Test 65, == works with characters</br>Test 66, if 0 is a boolean 'true'</br>Test 67, ELT returns CHARACTER of STRING</br>Test 68, NOT 0 is NIL</br>Test 69, %NCONC with NIL first</br>Test 70, %NCONC with NIL second</br>Test 71, LENGHT with conses</br>Test 72, LENGHT with strings</br>Test 73, CHARACTER- literal</br>Test 74, CHARACTER+ literal</br>Test 75, INTEGER- literal</br>Test 76, INTEGER+ literal</br>Test 77, == empty string</br>Test 78, EQUAL with CONS</br>Test 79, EQUAL fails on different lists</br>Test 80, ENQUEUE and QUEUE-LIST work</br>Test 81, MEMBER finds elements</br>Test 82, MEMBER finds elements with user predicate</br>Test 83, MEMBER falsely detects foureign elements</br>Test 84, can handle nested functions with double argument names</br>Test 85, can handle nested functions with double argument names</br>Test 86, can handle closures</br>Test 87, LAMBDA? works</br>Test 88, LAMBDA? works with LAMBDA</br>Test 89, LAMBDA-CALL? works</br>Test 90, $</br>Test 91, COPY-LIST works</br>Test 92, APPEND works with two lists</br>Test 93, APPEND works with empty lists</br>Test 94, APPEND works with three lists</br>Test 95, APPEND copies last</br>Test 96, NCONC works</br>Test 97, NCONC works with empty lists</br>Test 98, ADJOIN doesn't add known member</br>Test 99, ADJOIN adds new member</br>Test 100, REVERSE works</br>Test 101, NTHCDR basically works</br>Test 102, COPY-WHILE</br>Test 103, SUBSEQ basically works</br>Test 104, SUBSEQ works without end</br>Test 105, SUBSEQ returns NIL when totally out of range</br>Test 106, SUBSEQ returns empty string when start and end are the same</br>Test 107, DIGIT-CHAR? #0</br>Test 108, DIGIT-CHAR? #a</br>Test 109, ELT on string returns char</br>Test 110, ELT on string returns right char</br>Test 111, STRING== works</br>Test 112, LIST-STRING works</br>Test 113, STRING-LIST works</br>Test 114, STRING-UPCASE works</br>Test 115, STRING-DOWNCASE works</br>Test 116, FIND finds elements</br>Test 117, FIND accepts :FROM-END</br>Test 118, FIND accepts :END</br>Test 119, FIND accepts :START</br>Test 120, FIND accepts :START, :END, :FROM-END</br>Test 121, FIND-IF finds elements</br>Test 122, POSITION works with character list</br>Test 123, POSITION works with strings</br>Test 124, SOME works</br>Test 125, EVERY works</br>Test 126, BUTLAST basically works</br>Test 127, BUTLAST returns NIL for single cons</br>Test 128, HREF symbol key</br>Test 129, HREF number key</br>Test 130, HREF string key</br>Test 131, HREF empty string key</br>Test 132, HREF character key</br>Test 133, HREF hashtable key</br>Test 134, HREF array key</br>Test 135, argument expansion works with simple list</br>Test 136, argument expansion works without :apply-values</br>Test 137, argument expansion can handle nested lists</br>Test 138, argument expansion can handle nested lists without :apply-values</br>Test 139, argument expansion can handle &REST keyword</br>Test 140, argument expansion can handle &REST keyword without :apply-values</br>Test 141, argument expansion can handle missing &REST</br>Test 142, argument expansion can handle missing &REST without :apply-values</br>Test 143, argument expansion can handle &OPTIONAL keyword</br>Test 144, argument expansion can handle &OPTIONAL keyword without :apply-values</br>Test 145, argument expansion can handle &OPTIONAL keyword with init forms</br>Test 146, argument expansion can handle &OPTIONAL keyword with init forms without :apply-values</br>Test 147, argument expansion can handle &KEY keyword</br>Test 148, argument expansion can handle &KEY keyword with overloaded init forms</br>Test 149, argument expansion can handle &KEY keyword without :apply-values</br>Test 150, argument expansion can handle &OPTIONAL and &KEY keyword with init forms without :apply-values</br>Test 151, argument expansion can handle &OPTIONAL and &KEY keyword with init forms with :apply-values</br>Test 152, COUNT-IF</br>Test 153, <=-LIST: first list is less</br>Test 154, <=-LIST: equal</br>Test 155, <=-LIST: first list is greater</br>Test 156, SPLIT works on string</br>Test 157, SPLIT works on string with gaps</br>Test 158, TRIM-HEAD works</br>Test 159, TRIM-TAIL works</br>Test 160, TRIM works</br>Test 161, EMPTY-STRING? works</br>