(def-head-predicate %fname)
(def-head-predicate %vname)

(fn make-scope-place-expr (fi x)
  (funinfo-add-lexical fi x)
  `(%vec ,(funinfo-scope-arg fi)
         ,(funinfo-name (funinfo-parent fi))
         ,x))

(fn make-scope-place-1 (fi x)
  (? (funinfo-arg-or-var? (funinfo-parent fi) x)
     (make-scope-place-expr fi x)
     (make-scope-place-1 (funinfo-parent fi) x)))

(fn make-scope-place (fi x)
  (? (funinfo-scope-arg? fi x)
     x
     (progn
       (funinfo-setup-scope fi x)
       (!= (make-scope-place-1 fi x)
         `(%vec ,(place-expand-atom fi (make-scope-place fi .!.))
                ,..!.
                ,...!.)))))

(fn place-expand-emit-stackplace (fi x)
  `(%stack ,(funinfo-name fi) ,x))

(fn place-expand-atom (fi x)
  (?
    (| (literal? x)
       (not (funinfo-find fi x)
            (funinfo-global-var? fi x)))
      x
    (& (locals-on-stack?)
       (eq x (funinfo-scope fi)))
      (place-expand-emit-stackplace fi x)
    (& (lambda-export?)
       (not (eq x (funinfo-scope fi)))
       (funinfo-scoped-var? fi x))
      `(%vec ,(place-expand-atom fi (funinfo-scope fi))
             ,(funinfo-name fi)
             ,x)
    (| (& (locals-on-stack?)
          (funinfo-var? fi x))
       (& (arguments-on-stack?)
          (funinfo-arg? fi x)))
      (place-expand-emit-stackplace fi x)
    (funinfo-arg-or-var? fi x)
      `(%vname ,x ,(funinfo-name fi))
    (funinfo-global-var? fi x)
      (progn
        (funinfo-add-global fi x)
        (funinfo-add-var (global-funinfo) x)
        `(%global ,x))
    (lambda-export?)
      (make-scope-place fi x)
    x))

(fn place-expand-fun (x)
  (copy-lambda x :body (place-expand (lambda-body x) (lambda-funinfo x))))

(define-tree-filter place-expand (x &optional (fi (global-funinfo)))
  ; If an %FNAME is already there, it wants another FUNINFO look-up in codegen.
  (& (%fname? x)
     (not ..x))
    `(%fname ,.x. ,(funinfo-name fi))
  (& (not (funinfo-find fi x))
     (defined-function x))
    `(%fname ,x)
  (atom x)
    (place-expand-atom fi x)
  (| (quote? x)
     (%native? x)
     (%var? x)
     (%closure? x)
     (%function-prologue? x)
     (%function-epilogue? x)
     (%stackarg? x))
    x
  (named-lambda? x)
    (place-expand-fun x)
  (& (lambda-export?)
     (| (%=? x)
        (%set-local-fun? x))
     (%vec? (place-expand .x. fi)))
    (let p (place-expand .x. fi)
      `(%=-vec ,.p. ,..p. ,...p. ,(place-expand ..x. fi)))
  (%slot-value? x)
    `(%slot-value ,(place-expand .x. fi) ,..x.))
