; tré – Copyright (c) 2010–2015 Sven Michael Klose <pixel@hugbox.org>

(defun sloppy-equal (x needle)
  (& (atom x)
     (atom needle)
     (return (eql x needle)))
  (& (cons? x)
     (not needle)
     (return t))
  (& (cons? x)
     (cons? needle)
     (equal x. needle.)
     (sloppy-equal .x .needle)))

(defun tree-equal (x needle)
  (| (sloppy-equal x needle)
     (& (cons? x)
        (| (tree-equal x. needle)
           (tree-equal .x needle)))))

(defun dump-pass? (name x)
  (& *transpiler*
     (| (!? (dump-passes?)
            (| (t? !)
               (member name (ensure-list !))))
        (!? (dump-selector)
            (tree-equal x !)))))

(defmacro transpiler-end (name &rest name-fun-pairs)
  (print-definition `(transpiler-end ,name))
  `(defun ,name (x)
     (| (enabled-end? ,(make-keyword name))
        (return x))
     (when (t? (dump-passes?))
       (format t "~L; #### ~A ####~%" ',name))
     (with (outpass  (cdr (assoc ,(make-keyword name) (output-passes)))
            out      nil)
       (@ (i (list ,@(@ [`(. ,(make-keyword _.) ,._.)]
                        (group name-fun-pairs 2))))
         (when (enabled-pass? i.)
           (= x (with-global-funinfo (funcall .i x)))
           (= (last-pass-result) x)
           (when (eq outpass i.)
             (= out x))
           (when (dump-pass? i. x)
             (format t "~L; **** ~A output:~%" i.)
             (late-print x)
             (format t "~L; **** End of ~A~%" i.))))
       (? outpass out x))))
