; A dysfunctional tré bytecode interpreter for the good old 6502 CPU.
;
; Instructions:
; to move values into places:
;     SET place value
; to jump:
;     JMP target-bit target-byte
; to jump conditionally:
;     COND value target-bit target-byte
; to jump across pages or to return from a function:
;     JMPFAR target-page [target-byte]
;
; A value can be:
; - on the stack: '0' stack-index
; - a function call: '10' function-value num-args stack-indexes…
; - in a vector on the stack: '110' stack-index vector-index
; - on the functions constant list of pointers: '111' literal-index
;
: Stack-, literal- and vector-indexes have different but fixed widths
; throughout a function.
;
; A place can be:
; - on the stack: '0' stack-index
; - in a vector: '1' stack-index vector-index

;;;; Bit-wise code pointer

codeptr_bitmasks: .byt 1 2 4 8 16 32 64 128
codeptr_bitmask: .byt 1

;;;; The garbage-collected stack for return addresses and local variables.
stack .word

;;;; Information about the current function.
literals .word

(defmacro getbit ()
    (dec codeptr_bit)
    (bne >n1)
    (jsr getbit_step)
n1  (rol codeptr_value))

(defun getbit_step
    (ldx codeptr_index)
    (lda #8)
    (sta codeptr_bit)
    (inx)
    (stx codeptr_index)
    (lda (codeptr),x)
    (sta codeptr_value)
    (rts))

(defmacro readbit ()
    (GETBIT)
    (ROL current_index))

(defmacro read-bits (num)
  `(block
     (lda #0)
     ,@(multiply (fn `(readbit)) num)))

(defmacro read_stack_index () `(read-bits ,*stack-index-width*))
(defmacro read_literal_index () `(read-bits ,*literal-index-width*))
(defmacro read_vector_index () `(read-bits ,*vector-index-width*))

(defmacro ptr-add (macro place)
  `(block
     (clc)
     (adc place)
     (sta tmp_ptr)
     (lda #0)
     (adc place+1)
     (sta tmp_ptr+1)))

(defmacro ptr-to-value ()
  `(block
     (lda (tmp_ptr))
     (sta tmp_value)
     (lda (tmp_ptr),y)
     (sta tmp_value+1)))

(defmacro value-to-ptr ()
  `(block
     (lda tmp_value)
     (sta (tmp_ptr))
     (lda tmp_value+1)
     (sta (tmp_ptr),y)))

(defun get-stack ()
  '(block
     (read-stack-index)
     (ptr-add stack)
     (ptr-to-value)))

(defun get-literal ()
  '(block
     (read-literal-index)
     (ptr-add stack)
     (ptr-to-value)))

(defun get-funcall ()
  '(block
     (read-num-arguments)
     (tax)
     (pha)
     (init-stack-copier)
   loop
     (get-stack)
     (copy-stack)
     (dex)
     (bne leep)
     (pla)
     (ptr-add stack)
     (get-literal)


(defmacro get-vector ()
  '(block
     (get-stack)
     (value-to-ptr)
     (incw ptr)
     (read-vector-index)
     (ptr-add ptr)
     (ptr-to-value)))

(defmacro get-value ()
  '(block
     (read-bit)
     (bne try_literal)
     (get-stack)
     (bra got_value)
   try_literal
     (read-bit)
     (bne get_vector)
     (get-literal)
     (bra got_value)
   get_vector
     (get-vector)
   got_value))

(defmacro set-stack ()
  '(block
     (read-stack-index)
     (ptr-add stack)
     (value-to-ptr)))

(defmacro set-vector ()
  '(block
     (push-value)
     (get-stack)
     (value-to-ptr)
     (incw ptr)
     (read-vector-index)
     (ptr-add ptr)
     (pop-value)
     (value-to-ptr)))

SET_PLACE macro
    GETBIT
    bne try_set_vector
    SET_STACK
    bra place_is_set
try_set_vector:
    SET_VECTOR
place_is_set:
end

SET macro
    GET_VALUE
    SET_PLACE
end

MAKE_CODEPTR macro
    tax
    lda codeptr_bitmasks,x
end

JUMP macro
    GET_TARGET_BIT
    MAKE_CODEPTR_BIT
    GET_TARGET_BYTE
    sta codeptr_index
end

COND macro
    GET_COND_VALUE
    VALUE_NIL_P
    bne skip_cond
    JUMP
    bra end_of_cond
skip_cond:
    SKIP_COND_TARGET
end_of_cond:
end

JUMPFAR macro
    GET_TARGET_BYTE ; Destination page.
    beq function_return
    pha
    GET_TARGET_BYTE ; Destination byte in page.
    sta codeptr_index
    pla
    sta codeptr_page
    lda #0
    MAKE_CODEPTR_BIT
end

run:
    ldy #1
run_next:
    GETBIT
    bne try_cond
    SET
    bra run_next
try_cond:
    GETBIT
    bne try_jump
    COND
    bra run_next
try_jump:
    GETBIT
    bne jump_far
    JUMP
    bra run_next
jump_far:
    JUMP_FAR
    bra run_next
